import * as Lexer from "./lexer";
export declare function commonExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function boolCommonExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function andExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function orExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function leftRightExpr(value: number[] | Uint8Array, index: number, expr: string, tokenType: Lexer.TokenType): Lexer.Token;
export declare function eqExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function neExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function ltExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function leExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function gtExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function geExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function hasExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function addExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function subExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function mulExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function divExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function modExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function notExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function boolParenExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function parenExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function boolMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function methodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function methodCallExprFactory(value: number[] | Uint8Array, index: number, method: string, min?: number, max?: number): Lexer.Token;
export declare function containsMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function startsWithMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function endsWithMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function lengthMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function indexOfMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function substringMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function substringOfMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function toLowerMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function toUpperMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function trimMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function concatMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function yearMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function monthMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function dayMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function hourMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function minuteMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function secondMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function fractionalsecondsMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function totalsecondsMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function dateMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function timeMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function totalOffsetMinutesMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function minDateTimeMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function maxDateTimeMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function nowMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function roundMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function floorMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function ceilingMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function distanceMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function geoLengthMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function intersectsMethodCallExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function isofExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function castExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function negateExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function firstMemberExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function memberExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function propertyPathExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function inscopeVariableExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function implicitVariableExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function lambdaVariableExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function lambdaPredicateExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function anyExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function allExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function collectionNavigationExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function keyPredicate(value: number[] | Uint8Array, index: number, metadataContext?: any): Lexer.Token;
export declare function simpleKey(value: number[] | Uint8Array, index: number, metadataContext?: any): Lexer.Token;
export declare function compoundKey(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function keyValuePair(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function keyPropertyValue(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function keyPropertyAlias(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function singleNavigationExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function collectionPathExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function complexPathExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function singlePathExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function functionExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function boundFunctionExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function functionExprParameters(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function functionExprParameter(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function parameterName(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function parameterAlias(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function parameterValue(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function countExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function refExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function valueExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
export declare function rootExpr(value: number[] | Uint8Array, index: number): Lexer.Token;
